## Dupin
[![Maven Central](https://img.shields.io/maven-central/v/com.github.yakivy/dupin-core_2.12.svg)](https://mvnrepository.com/search?q=dupin)
[![Sonatype Nexus (Snapshots)](https://img.shields.io/nexus/s/https/oss.sonatype.org/com.github.yakivy/dupin-core_2.13.svg)](https://oss.sonatype.org/content/repositories/snapshots/com/github/yakivy/dupin-core_2.13/)
[![Build Status](https://travis-ci.com/yakivy/dupin.svg?branch=master)](https://travis-ci.com/yakivy/dupin)
[![codecov.io](https://codecov.io/gh/yakivy/dupin/branch/master/graphs/badge.svg?branch=master)](https://codecov.io/github/yakivy/dupin/branch/master)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
<a href="https://typelevel.org/cats/"><img src="data:image/png;base64,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" height="40px" align="right" alt="Cats friendly" /></a>

Dupin is a minimal, idiomatic, customizable validation Scala library.

### Table of contents
1. [Motivation](#motivation)
1. [Quick start](#quick-start)
1. [Predefined validators](#predefined-validators)
1. [Customization](#message-customization)
    1. [Message customization](#message-customization)
    1. [Kind customization](#kind-customization)
    1. [Custom validating package](#custom-validating-package)

### Motivation

You may find Dupin useful if you want to...
- return something richer than `String` as validation message
- use custom data kind for validation (`Future`, `IO`, etc...)
- reuse validation parts across whole project

### Quick start
Add dupin dependency to the build file, let's assume you are using sbt:
```scala
libraryDependencies += Seq(
  "com.github.yakivy" %% "dupin-core" % "0.1.4"
)
```
Describe the domain:
```scala
case class Name(value: String)
case class Member(name: Name, age: Int)
case class Team(name: Name, members: Seq[Member])
```
Define some validators:
```scala
import cats.implicits._
import dupin.base.all._

implicit val nameValidator = BaseValidator[Name]
    .root(_.value.nonEmpty, _.path + " should be non empty")

implicit val memberValidator = BaseValidator[Member]
    .combineP(_.name)(nameValidator)
    .combinePR(_.age)(a => a > 18 && a < 40, _.path + " should be between 18 and 40")

implicit val teamValidator = BaseValidator[Team].derive
    .combineR(_.members.size <= 8, _ => "team should be fed with two pizzas!")
```
Validate them all:
```scala
import dupin.base.all._

val validTeam = Team(
    Name("Bears"),
    List(
        Member(Name("Yakiv"), 26),
        Member(Name("Myroslav"), 31),
        Member(Name("Andrii"), 25)
    )
)

val invalidTeam = Team(
    Name(""),
    Member(Name(""), 0) :: (1 to 10).map(_ => Member(Name("valid name"), 20)).toList
)

val valid = validTeam.isValid
val result = invalidTeam.validate

assert(valid)
assert(result == Validated.invalid(NonEmptyChain(
    ".name should be non empty",
    ".members.[0].name should be non empty",
    ".members.[0].age should be between 18 and 40",
    "team should be fed with two pizzas!"
)))
```

### Predefined validators

The more validators you have, the more logic can be reused without writing validators from the scratch. Let's define common validators for minimum and maximum `Int` value:
```scala
import dupin.base.all._

def min(value: Int) = BaseValidator[Int].root(_ > value, _.path + " should be greater than " + value)
def max(value: Int) = BaseValidator[Int].root(_ < value, _.path + " should be less than " + value)
``` 
And since validators can be combined, you can create validators from other validators:
```scala
import dupin.base.all._

implicit val memberValidator = BaseValidator[Member].path(_.age)(min(18) && max(40))

val invalidMember = Member(Name("Ada"), 0)
val result = invalidMember.validate

assert(result == Validated.invalidNec(".age should be greater than 18"))
```
You can find full list of validators that provided out of the box in `dupin.instances.DupinInstances`

### Message customization

But not many real projects use strings as validation messages, for example you want to support internationalization:
```scala
case class I18nMessage(
    description: String,
    key: String,
    params: List[String]
)
```
As `BaseValidator[A]` is just a type alias for `Validator[Id, String, A]`, you can define own validator type with builder:

```scala
import dupin._

type I18nValidator[A] = Validator[I18nMessage, A, cats.Id]
def I18nValidator[A] = Validator[I18nMessage, A, cats.Id]
```
And start creating validators with custom messages:
```scala
implicit val nameValidator = I18nValidator[Name].root(_.value.nonEmpty, c => I18nMessage(
    c.path + " should be non empty",
    "validator.name.empty",
    List(c.path.toString())
))

implicit val memberValidator = I18nValidator[Member]
    .combinePI(_.name)
    .combinePR(_.age)(a => a > 18 && a < 40, c => I18nMessage(
        c.path + " should be between 18 and 40",
        "validator.member.age",
        List(c.path.toString())
    ))
```
Validation messages will look like:
```scala
import dupin.syntax._

val invalidMember = Member(Name(""), 0)
val result = invalidMember.validate

assert(result == Validated.invalid(NonEmptyChain(
    I18nMessage(
        ".name should be non empty",
        "validator.name.empty",
        List(".name")
    ),
    I18nMessage(
        ".age should be between 18 and 40",
        "validator.member.age",
        List(".age")
    )
)))
```

### Kind customization

For example you want to allow only using of limited list of names and they are stored in the database:
```scala
import scala.concurrent.Future

class NameService {
    private val allowedNames = Set("Ada")
    def contains(name: String): Future[Boolean] =
        // Emulation of DB call
        Future.successful(allowedNames(name))
}
```
So to be able to handle checks that returns `Future[Boolean]`, you just need to define your own validator type with builder:

```scala
import cats.Applicative
import dupin._
import scala.concurrent.Future

type FutureValidator[A] = Validator[Future, String, A]
def FutureValidator[A](implicit A: Applicative[Future]) = Validator[Future, String, A]
``` 
Then you can create validators with generic dsl (don't forget to import required type classes, as minimum `Functor[Future]`):
```scala
import cats.implicits._
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future

val nameService = new NameService

implicit val nameValidator = FutureValidator[Name].root(
    n => nameService.contains(n.value), _.path + " should be non empty"
)

implicit val memberValidator = FutureValidator[Member]
    .combinePI(_.name)
    .combinePR(_.age)(a => Future.successful(a > 18 && a < 40), _.path + " should be between 18 and 40")
```
Validation result will look like:
```scala
import dupin.syntax._

val invalidMember = Member(Name(""), 0)
val result: Future[ValidatedNec[String, Member]] = invalidMember.validate

assert(Await.result(result, Duration.Inf) == Validated.invalid(NonEmptyChain(
    ".name should be non empty",
    ".age should be between 18 and 40"
)))
```

### Custom validating package

To avoid imports boilerplate and isolating all customizations you can define your own dupin package:

```scala
import cats.Applicative
import dupin.readme.MessageCustomizationDomainFixture._
import dupin.syntax.DupinSyntax
import scala.concurrent.Future

package object custom extends DupinCoreDsl with DupinSyntax {
    type CustomValidator[A] = Validator[Future, I18nMessage, A]
    def CustomValidator[A](implicit A: Applicative[Future]) = Validator[Future, I18nMessage, A]
}
```
Then you can start using your own validator type with single import:
```scala
import dupin.custom._
import cats.implicits._
import scala.concurrent.ExecutionContext.Implicits.global

val nameService = new NameService

implicit val nameValidator = CustomValidator[Name].root(
    n => nameService.contains(n.value), c => I18nMessage(
        c.path + " should be non empty",
        "validator.name.empty",
        List(c.path.toString())
    )
)

val validName = Name("Ada")
val valid: Future[Boolean] = validName.isValid

assert(Await.result(valid, Duration.Inf))
```